# Go语言手册
1 Go语言简介

		1.1 Go语言简介
		1.2 Go语言的特性
		1.3 Go语言为并发而生
		1.4 哪些项目使用Go语言开发？
		1.5 哪些大公司正在使用Go语言
		1.6 Go语言适合做什么
		1.7 Go语言和其它编程语言的对比
		1.8 Go语言的性能如何？
		1.9 Go语言标准库强大
		1.10 Go语言上手简单
		1.11 Go语言代码风格清晰、简单
		1.12 Go语言是怎么完成编译的
		1.13 在Windows上安装Go语言开发包
		1.14 在Linux上安装Go语言开发包
		1.15 在Mac OS上安装Go语言开发包
		1.16 Go语言集成开发环境
		1.17 Go语言工程结构详述
		1.18 Go语言依赖管理
2 Go语言基本语法

		2.1 Go语言变量的声明
		2.2 Go语言变量的初始化
		2.3 Go语言多个变量同时赋值
		2.4 Go语言匿名变量
		2.5 Go语言变量的作用域
		2.6 Go语言整型（整数类型）
		2.7 Go语言浮点类型（小数类型）
		2.8 Go语言复数
		2.9 实例：输出正弦函数（Sin）图像
		2.10 Go语言bool类型（布尔类型）
		2.11 Go语言字符串
		2.12 Go语言字符类型（byte和rune）
		2.13 Go语言数据类型转换
		2.14 Go语言指针
		2.15 Go语言变量逃逸分析
		2.16 Go语言变量的生命周期
		2.17 Go语言常量
		2.18 Go语言模拟枚举
		2.19 Go语言类型别名
		2.20 Go语言注释的定义及使用
		2.21 Go语言关键字与标识符
		2.22 Go语言字符串和数值类型的相互转换
3 Go语言容器

		3.1 Go语言数组
		3.2 Go语言多维数组
		3.3 Go语言切片
		3.4 使用append()为切片添加元素
		3.5 Go语言切片复制
		3.6 Go语言从切片中删除元素
		3.7 Go语言range关键字
		3.8 Go语言多维切片
		3.9 Go语言map（映射）
		3.10 Go语言遍历map
		3.11 map元素的删除和清空
		3.12 Go语言sync Map
		3.13 Go语言list（列表）
		3.14 Go语言nil：空值/零值
		3.15 Go语言进制与转换
		3.16 Go语言make和new关键字的区别及实现原理
4 流程控制

		4.1 Go语言分支结构
		4.2 Go语言运算符及优先级
		4.3 Go语言循环结构
		4.4 输出九九乘法表
		4.5 Go语言键值循环
		4.6 Go语言switch语句
		4.7 Go语言goto语句
		4.8 Go语言break（跳出循环）
		4.9 Go语言continue
		4.10 示例：聊天机器人
		4.11 示例：词频统计
		4.12 示例：缩进排序
		4.13 示例：二分查找算法
		4.14 示例：冒泡排序
5 Go语言函数

		5.1 Go语言函数类型
		5.2 Go语言函数声明
		5.3 Go语言函数值传递和引用传递
		5.4 Go语言函数的多返回值
		5.5 示例：将秒转换为具体的时间
		5.6 示例：函数中的参数传递效果测试
		5.7 Go语言函数变量
		5.8 Go语言字符串的链式处理
		5.9 Go语言匿名函数
		5.10 Go语言函数类型实现接口
		5.11 Go语言闭包（Closure）
		5.12 Go语言可变参数
		5.13 Go语言defer（延迟执行语句）
		5.14 Go语言递归函数
		5.15 Go语言处理运行时错误
		5.16 Go语言宕机（panic）
		5.17 Go语言宕机恢复（recover）
		5.18 Go语言计算函数执行时间
		5.19 示例：将函数作为返回值
		5.20 示例：通过内存缓存来提升性能
		5.21 Go语言函数的底层实现
		5.22 Go语言错误处理策略
		5.23 Go语言Test功能测试函数
6 Go语言结构体

		6.1 Go语言结构体定义
		6.2 Go语言实例化结构体
		6.3 初始化结构体的成员变量
		6.4 Go语言结构体字面量
		6.5 Go语言构造函数
		6.6 Go语言方法和接收器
		6.7 为任意类型添加方法
		6.8 示例：使用事件系统实现事件的响应和处理
		6.9 类型内嵌和结构体内嵌
		6.10 结构体内嵌模拟类的继承
		6.11 初始化内嵌结构体
		6.12 内嵌结构体成员名字冲突
		6.13 示例：使用匿名结构体解析JSON数据
		6.14 Go语言垃圾回收和SetFinalizer
		6.15 示例：使用事件系统实现事件的晌应和处理
		6.16 示例：将结构体数据保存为JSON格式数据
		6.17 Go语言链表操作
		6.18 Go语言数据I/O对象及操作
7 Go语言接口

		7.1 Go语言接口声明（定义）
		7.2 Go语言实现接口的条件
		7.3 Go语言类型与接口的关系
		7.4 Go语言类型断言
		7.5 示例：Go语言实现日志系统
		7.6 Go语言排序
		7.7 Go语言接口的嵌套组合
		7.8 Go语言接口和类型之间的转换
		7.9 Go语言空接口类型
		7.10 示例：使用空接口实现可以保存任意值的字典
		7.11 Go语言类型分支
		7.12 Go语言error接口
		7.13 Go语言Writer和Reader接口
		7.14 Go语言接口内部实现
		7.15 示例：表达式求值器
		7.16 使用类型断言来识别错误
		7.17 接口与动态类型
		7.18 示例：简单的Web服务器
		7.19 示例：音乐播放器
		7.20 示例：使用空接口实现可以保存任意值的字典
		7.21 示例：实现有限状态机（FSM）
		7.22 示例：二叉树数据结构的应用
8 Go语言包（package）

		8.1 包的基本概念
		8.2 Go语言封装简介及实现细节
		8.3 Go语言GOPATH
		8.4 Go语言常用内置包
		8.5 Go语言自定义包
		8.6 Go语言package
		8.7 Go语言导出包中的标识符
		8.8 Go语言import导入包
		8.9 Go语言工厂模式自动注册
		8.10 Go语言单例模式
		8.11 Go语言sync包与锁
		8.12 Go语言big包
		8.13 示例：使用图像包制作GIF动画
		8.14 Go语言正则表达式：regexp包
		8.15 Go语言time包：时间和日期
		8.16 Go语言os包用法简述
		8.17 Go语言flag包：命令行参数解析
		8.18 Go语言go mod包依赖管理工具
		8.19 示例：使用Go语言生成二维码
		8.20 Go语言Context（上下文）
		8.21 示例：客户信息管理系统
		8.22 示例：使用Go语言发送电子邮件
		8.23 Go语言（Pingo）插件化开发
		8.24 Go语言定时器实现原理及作用
		8.25 Go语言使用定时器实现任务队列
9 Go语言并发

		9.1 Go语言并发简述
		9.2 Go语言轻量级线程
		9.3 Go语言并发通信
		9.4 Go语言竞争状态
		9.5 Go语言调整并发的运行性能
		9.6 并发和并行的区别
		9.7 goroutine和coroutine的区别
		9.8 Go语言通道（chan）
		9.9 示例：并发打印
		9.10 Go语言单向通道
		9.11 Go语言无缓冲的通道
		9.12 Go语言带缓冲的通道
		9.13 Go语言channel超时机制
		9.14 Go语言通道的多路复用
		9.15 Go语言模拟远程过程调用
		9.16 示例：使用通道响应计时器的事件
		9.17 Go语言关闭通道后继续使用通道
		9.18 Go语言多核并行化
		9.19 Go语言Telnet回音服务器
		9.20 检测代码在并发环境下可能出现的问题
		9.21 互斥锁和读写互斥锁
		9.22 Go语言等待组
		9.23 死锁、活锁和饥饿概述
		9.24 示例：封装qsort快速排序函数
		9.25 Go语言CSP：通信顺序进程简述
		9.26 示例：聊天服务器
10 Go语言反射

		10.1 Go语言反射（reflection）
		10.2 Go语言反射规则浅析
		10.3 通过反射获取类型信息
		10.4 通过反射获取指针指向的元素类型
		10.5 通过反射获取结构体的成员类型
		10.6 Go语言结构体标签
		10.7 通过反射获取值信息
		10.8 示例：使用reflect Type显示一个类型的方法集
		10.9 通过反射访问结构体成员的值
		10.10 判断反射值的空和有效性
		10.11 通过反射修改变量的值
		10.12 示例：获取结构体字段标识
		10.13 通过类型信息创建实例
		10.14 通过反射调用函数
		10.15 Go语言inject库：依赖注入
11 Go语言网络编程

		11.1 Go语言Socket编程
		11.2 Dial()函数
		11.3 示例：使用ICMP协议向主机发送消息
		11.4 示例：建立TCP链接
		11.5 Go语言DialTCP()
		11.6 HTTP客户端实现简述
		11.7 服务端处理HTTP、HTTPS请求
		11.8 RPC协议：远程过程调用
		11.9 如何设计优雅的RPC接口
		11.10 解码未知结构的JSON数据
		11.11 Go语言如何搭建网站程序
		11.12 示例：开发一个简单的相册网站
		11.13 数据库（Database）相关操作
		11.14 示例：并发时钟服务器
		11.15 Go语言router请求路由
		11.16 Go语言middleware：Web中间件
		11.17 Go语言常见大型Web项目分层（MVC架构）
		11.18 Cookie的设置与读取
		11.19 示例：获取IP地址和域名解析
		11.20 Go语言TCP网络程序设计
		11.21 Go语言UDP网络程序设计
		11.22 Go语言IP网络程序设计
		11.23 Go语言是如何使得Web工作的
		11.24 Go语言session的创建和管理
		11.25 Go语言Ratelimit服务流量限制
		11.26 Go语言WEB框架(Gin)详解
12 Go语言文件处理

		12.1 Go语言自定义数据文件
		12.2 Go语言JSON文件的读写操作
		12.3 Go语言XML文件的读写操作
		12.4 Go语言使用Gob传输数据
		12.5 Go语言纯文本文件的读写操作
		12.6 Go语言二进制文件的读写操作
		12.7 Go语言自定义二进制文件的读写操作
		12.8 Go语言zip归档文件的读写操作
		12.9 Go语言tar归档文件的读写操作
		12.10 Go语言使用buffer读取文件
		12.11 Go语言使用切片读写文件
		12.12 示例：并发目录遍历
		12.13 示例：从INI配置文件中读取需要的值
		12.14 Go语言文件的写入、追加、读取、复制操作
		12.15 Go语言文件锁操作
13 Go语言网络爬虫

		13.1 Go语言网络爬虫概述
		13.2 Go语言网络爬虫中的基本数据结构
		13.3 Go语言网络爬虫的接口设计
		13.4 Go语言网络爬虫缓冲器工具的实现
		13.5 Go语言网络爬虫缓冲池工具的实现
		13.6 Go语言网络爬虫多重读取器的实现
		13.7 Go语言网络爬虫内部基础接口
		13.8 Go语言网络爬虫组件注册器
		13.9 Go语言网络爬虫下载器接口
		13.10 Go语言网络爬虫分析器接口
		13.11 Go语言网络爬虫条目处理管道
		13.12 Go语言网络爬虫调度器的实现
		13.13 示例：爬取图片小程序
14 Go语言编译与工具

		14.1 go build命令
		14.2 go clean命令
		14.3 go run命令
		14.4 go fmt命令
		14.5 go install命令
		14.6 go get命令
		14.7 go generate命令
		14.8 go test命令
		14.9 go pprof命令
15 “避坑”与技巧

		15.1 高效地使用Go语言并发特性
		15.2 反射——性能和灵活性的双刃剑
		15.3 接口的nil判断
		15.4 Go语言map的多键索引
		15.5 与C/C++进行交互
		15.6 Go语言文件读写
		15.7 Json数据编码和解码
		15.8 使用select切换协程
		15.9 Go语言加密通信
		15.10 Go语言内存管理
		15.11 Go语言垃圾回收
		15.12 Go语言哈希函数
		15.13 Go语言分布式id生成器
		15.14 部署Go语言程序到Linux服务器
		15.15 Go语言实现RSA和AES加解密